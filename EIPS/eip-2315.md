---
eip: 4951
title: Static Control Flow
description: Five opcodes for efficient, safe, and static control flow.
author: Greg Colvin (@gcolvin), Martin Holst Swende (@holiman), Brooklyn Zelenka (@expede), John Max Skaller <skaller@internode.on.net>
discussions-to: https://ethereum-magicians.org/t/eip------static-control-flow-for-the-evm/3941
status: Draft
type: Standards Track
category: Core
created: 2019-10-17
requires: 3541, 3670, 4200
---

## Abstract

This proposal provides a _complete_, _efficient_, _safe_ and _static_ control-flow facility.

It introduces two new opcodes to support calls and returns:

* `RCALLSUB relative_offset` -- call to `relative_offset` from `PC`.
* `RETURNSUB` -- return to `PC` after most recent `RCALLSUB`.

It depends on the two new opcodes proposed by [EIP-4200](./eip-4200.md) to support static jumps:

* `RJUMP relative_offset` —  jump to `relative_offset` from `PC`.
* `RJUMPI relative_offset` — conditional relative jump.

And restricts the valid use of `JUMP` and `JUMPI` to `PUSH dst JUMP` and `PUSH dst JUMPI`.

In concert with [EIP-3541](./eip-3541.md) and [EIP-3670](./eip-3670.md) it ensures, at initialization time, that valid code will not execute invalid instructions or jump to invalid locations, will not underflow stack, and will have bounded stack height in the absence of recursion.

This is the simplest possible proposal that meets these requirements.

## Motivation

### The original control-flow facility.

Jumps, conditional jumps, calls, and returns were proposed by Alan Turing in 1945 as a means of organizing the logic of the code and the design of the memory crystals for his Automatic Computing Engine:
> We wish to be able to arrange that sequences of orders can divide at various points, continuing in different ways according to the outcome of the calculations to date...  We also wish to be able to arrange for the splitting up of operations into subsidiary operations... To start on a subsidiary operation we need only make a note of where we left off the major operation and then apply the first instruction of the subsidiary.  When the subsidiary is over we look up the note and continue with the major operation.
>
> — Alan Turing, 1945 — in B.E. Carpenter, R.W. Doran, "The other Turing machine." The Computer Journal, Volume 20, Issue 3, January 1977.

The details vary, but similar facilities have proven their value across a long line of important machines over the last 75 years, including most all of the machines we have programmed or implemented -- physical machines including the Burroughs 5000, CDC 7600, IBM 360, DEC PDP-11 and VAX, Motorola 68000, Sun SPARC, and Intel x86s, as well as virtual machines for Scheme, Forth, Pascal, Java, Wasm, and others.

Unlike these machines, the Ethereum Virtual Machine _does not_ provide operations for calls and returns. Instead, they must be synthesized using the dynamic `JUMP` instruction, which takes its destination on the stack. Further, the EVM provides _only_ dynamic jumps.  The EVM's dynamic jumps cause two major problems. First, the need to synthesize static jumps and calls with dynamic jumps wastes space and gas with needlessly complex code, as we will show below.

Worse, jumps that can dynamically branch to any destination in the code can cause quadratic "path explosions" when traversing the flow of control. For Ethereum, this is a denial-of-service vulnerability that prevents us, at initialization time, from validating the safe use of EVM code to compiling EVM code to machine code -- in time and space linear in the size of the code.  Let us explain.

Consider the following block of code, with the loop at byte 6:
```
 0: jumpdest
 1: push 3
 3: push 4
 5: add
 6: jumpi
 7: jumpdest
```
Except there is no loop -- the `jumpi` will always jump to byte 7.

An algorithm attempting to trace the control flow without running the program cannot know this.  Compound this uncertainty across every jump in a program and the number of possible traces goes up quadratically with the contract size.  So `JUMP` and `JUMPI` are DoS attack surfaces for any static analyses which involve tracing control flow, including:
* validating EVM code before loading it onchain,
* optimizing EVM code for faster interpretation, and
* compiling EVM code for execution on real machines and zkVMs.

The value of these analyses is greater onchain security and higher performance EVM code.  Quadradic-time (and worse) traces are also a huge obstacle to proofs of correctness and other formal security work off-chain, especially in-depth and at-scale.  These formal security analyses are of obvious value, with immense quantities of valuable Ether at stake, and they are all impeded by dynamic jumps.

[EIP-4200](./eip-4200.md) provides static `RJUMP` and `RUMPI` opcodes as alternatives to dynamic jumps, and this proposal validates only static use of `JUMP` and `JUMPI`.  The one dynamic use of `JUMP` which cannot be tamed is Turing's _subsidiary operations._  For that purpose we propose `RCALLSUB` and `RETURNSUB` opcodes.

## Specification

### Opcodes

#### `MAGIC (0xEFFF) data_offset code_offset`

Must be the first operation of a validated program.
Pushes the `data offset` on the `data stack`.
Transfers control to `code_offset` which MUST be the next executable operation in the bytecode. 

1. Push the current `PC` to the `return stack`.
2. Push the `data_offset` to the `data stack`.
3. Set `PC` to `PC + code_offset`.
* The `code_offset` and `data_offset` are relative to the beginning of the program.
  * The offsets are encoded as a two-byte, twos-complement signed integers, stored MSB-first.
* Space between the data offset and the end of the program is reserved to the user.
* Space between the code offset and its destination is reserved to the implementation.

#### `RCALLSUB (0x5f) relative_offset`

Transfers control to a subsidiary operation.

1. Decode the `relative_offset` from the immediate data at `PC`.
2. Push the current `PC + 3` to the `return stack`.
3. Set `PC` to `PC + relative_offset`.

The `relative_offset` is relative to the current `PC`. The offset is encoded as a two-byte, twos-complement signed integer, stored MSB-first.

The gas cost is _low_.

#### `RETURNSUB (0x5e)`

Returns control to the caller of a subsidiary operation.

1. Pop the `return stack` to `PC`.

The gas cost is _verylow_.

_Notes:_

* _Values popped off the `return stack` do not need to be validated, since they are alterable only by `RCALLSUB` and `RETURNSUB`._
* _The description above lays out the semantics of these instructions in terms of a `return stack`.  But the actual state of the `return stack` is not observable by EVM code or consensus-critical to the protocol.  (For example, a node implementer may code `RCALLSUB` to unobservably push `PC` on the `return stack` rather than `PC + 1`, which is allowed so long as `RETURNSUB` observably returns control to the `PC + 3` location.)_
* _This EIP does not prescribe the use of the space between the `code_offset` and the code it points at.  A Working Group's headers might be a useful application._ 

### Validity

_Execution_ is defined in the Yellow Paper as a sequence of changes in the EVM state.  The conditions on valid code are preserved by state changes.  At runtime, if execution of an instruction would violate a condition the execution is in an exceptional halting state.  The Yellow Paper defines six such states.

1. Insufficient gas
2. More than 1024 stack items
3. State modification during a static call
4. Insufficient stack items
5. Invalid jump destination
6. Invalid instruction

We would like to consider EVM code valid iff no execution of the program can lead to an exceptional halting state.  In practice, we must test at runtime for the first three conditions.  We don’t know how much gas there will be, we don’t know how deep a recursion may go, analysis of stack depth even for non-recursive programs is nontrivial, and we don't know whether a call will be static.  All of the remaining conditions MUST be validated statically, in time and space linear in the size of the code.

#### **Contracts that begin with `0xEFFF` MUST be Valid**
* Every instruction MUST be valid:
   * The `JUMP`, `JUMPI`, `RJUMP`, `RJUMPI`, or `RCALLSUB` instructions MUST NOT address immediate data.
* The stacks MUST be valid:
   * The number of items on the `data stack` MUST always be positive.
   * The number of items on the `return stack` MUST always be positive.
* The _data stack_ MUST be consistently aligned:
   * The _data stack height_ is the absolute difference between the current `stack pointer` and the `stack pointer` on entry to the current subsidiary.
   * This _height_ MUST be _the same_ for every _backwards branch_, that is, a reachable path through a given `PC` where
         * the `IP` points to `RJUMP rdst` or `RJUMPI rdst`  and `rdst < 0`, or where 
         * the `IP` points to `PUSH dst JUMP` or `PUSH dst JUMPI` and `dst - PC < 0`.
   * This _height_ MUST NOT exceed 1024.

## Rationale

This is a purely semantic specification, placing no constraints on the syntax of code sections beyond being a sequence of opcodes and immediate data – subsidiary operations are not contiguous sequences of bytecode, they are subgraphs of the bytecode's full control-flow graph.  The EVM is a simple state machine.  We only promise that valid code will not, as it were, jam up the gears of the machine.  With no syntactic constraints and minimal semantic constraints we maximize opportunities for optimizations, include tail call elimination, multiple-entry calls, jumps to common exit handlers, arranging blocks for optimal caching and variables for efficient register allocation, and more.  Since we want to support online compilation of EVM code to native and ZK code it is crucial that the EVM code be as well optimized as possible offline.

### Validation

Rather than enforce constraints via syntax, we enforce them via validation.

The constraints on valid code cover all of the exceptional halting states that we can validate and allow code to be validated and compiled in time and space linear in the size of the code.

The `RJUMP`, `RJUMPI` and `RCALLSUB` instructions take their _relative_offset_ as immediate arguments, which cannot change at runtime.  Having constant destinations for all backwards jumps means that all jump destinations can be validated at initialization time, not runtime.  Dynamic jumps can branch to any destination in the code,  but requiring constant `JUMP` and `JUMPI` arguments prevents quadratic "path explosions"  when tracing the control flow.

Requiring a consistently aligned `data stack`

* prevents stack underflow
* ensures that stack height is bounded in the absence of recursion.

Requiring a consistently aligned `data stack` also allows some algorithms that trace the control-flow graph -- including code validation and compilation -- to break cycles at joins, again preventing quadratic path explosion.  When a traversal gets to a `PC` it has visited before it is either at the beginning of a loop or the entry to a function.  Since the stack height at a backwards branch is constant we know that loops will not grow stack -- there will be no need to trace that path again.

_Note: The JVM and Wasm enforce similar constraints for similar reasons._

### Efficiency

We illustrate here how simple instructions for calls and returns can be used to reduce the complexity and gas costs of both ordinary and optimized calls compared to using `JUMP`.

#### **Simple Call**

Consider these examples of a fairly minimal call, including the code to call it.

##### Using `RCALLSUB`:

```
SQUARE:
    dup1            ; 3 gas
    mul             ; 5 gas
    returnsub       ; 3 gas

CALL_SQUARE:
    push 0x02       ; 3 gas
    rcallsub SQUARE ; 5 gas
```

_Total gas: 19_

##### Using `JUMP`:

```
SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    swap1           ; 3 gas
    jump            ; 8 gas

CALL_SQUARE:
    jumpdest        ; 1 gas
    push RTN_CALL:  ; 3 gas
    push 0x02       ; 3 gas
    push SQUARE     ; 3 gas
    jump            ; 8 gas
RTN_CALL:
    jumpdest        ; 1 gas
```

_Total: 39 gas_.

Using `RCALLSUB` versus `JUMP` saves _39 - 19 = 20 gas_ -- a _51%_ improvement.

#### **Tail Call Optimization**

Of course in cases like this one we can optimize the tail call, so that the return from `SQUARE` actually returns from `TEST_SQUARE`.

##### Tail call optimization, using `RCALLSUB` and `RETURNSUB`:

```
SQUARE:
    dup1            ; 3 gas
    mul             ; 5 gas
    returnsub       ; 3 gas

CALL_SQUARE:
    push 0x02       ; 3 gas
    rjump SQUARE    ; 3 gas
```

_Total: 17 gas_


##### Tail call optimization, using `JUMP`:

```
SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    swap2           ; 3 gas

CALL_SQUARE:
    push 0x02       ; 3 gas
    push SQUARE     ; 3 gas
    jump            ; 8 gas
```

_Total: 26 gas_

Using `RCALLSUB` versus `JUMP` saves _26 - 17 = 19 gas_ — a _65%_ improvement.

#### Efficiency Caveats

We can see that these instructions provide a simpler and more gas-efficient mechanism than using `JUMP` — in our examples they cut gas use by at least half.

Clearly, the benefits of this efficiency are greater for programs that have been factored into smaller calls -- the overhead for calling and returning from a call with `RCALLSUB` and `RETURNSUB` is only 8 gas, whereas the overhead for `JUMP` is 28 gas.

### Alternative Designs

There are a few major designs for calls and returns, two of which we consider here.  The others are mostly not appropriate for the EVM, such as the Wheeler Jump -- self-modifying code that writes return addresses into itself, or branch-and-link, which uses special registers to support coroutines.

1. _Keep return addresses on a dedicated return stack._ Turing's design is often used by stack machines, including those for Forth, Java, Wasm, and others.  The data stack is used for computation, with a dedicated stack for return addresses.  A single instruction suffices to call, and another to return from a routine.

2. _Keep return addresses on the data stack._  This design is often used by register machines, including those from CDC, IBM, DEC, Intel, and ARM.  The registers are used primarily for computation, and the stack maintains call frames for return addresses, arguments, and local variables.  On the EVM there are no registers for computation, so using the stack for both purposes can cause the sort of inefficiencies we see above.

#### We prefer the dedicated return stack.

* It maintains a clear separation between calculation and flow of control:
  * the data stack is free of vulnerable return addresses and
  * it's impossible to overwrite the return stack.
* It improves efficiency:
  * it uses native arithmetic rather than 256-bit EVM instructions for the return address,
  * doesn't use up a `data stack` slot for the return address and
  * needs less motion of 256-bit data on the stack.

#### Why no object format?

There is just the bare minimum for future use at inittime, and even that turns into a jump function at runtime, leaving some room at the beginnng for headers and some room at the end for user data.  Importantly, the headers are not part of consensus at runtime.  The argument is that object formats are contracts between compilers and linkers.  Linkers promise to produce running executables given properly configured object files.  Likewise, most of the object system should be removed from consensus -- the objects described by the headers could be resolved by some sort of linker phase into executables before they get to consensus code, with standards set by working groups including stakeholders doing compilers, proofs, zkEVMs, and more.

### Costs

The _low_ cost of `RCALLSUB` versus the _mid_ cost of `JUMP` is justified by needing only to decode the immediate two byte destination to the `PC` and push the return address on the `return stack`, all using native arithmetic, versus using the data stack with emulated 256-bit instructions.

The _verylow_ cost of `RETURNSUB` is justified by needing only to pop the `return stack` into the `PC`.  Benchmarking will be needed to tell if the costs are well-balanced.

## Backwards Compatibility

These changes do not affect the semantics of existing EVM code, with the caveat that bytes that would have been interpreted as valid jump destinations may now be interpreted as immediate data, and bytecode that might have halted a program will now execute.  Such code was always broken.  The semantics of existing or new opcodes is not affected by whether the contract begins with `0xEFFF` -- only their validity.

## Test Cases

### Simple routine

This should jump into a call, back out and stop.

Bytecode: `0x5f0003005e` (`RCALLSUB 3, RETURNSUB, STOP`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |   RCALLSUB  |    5 |        [] |        [] |
|    2  |       STOP  |    0 |        [] |        [] |
|    3  |  RETURNSUB  |    3 |        [] |        [] |

Output: 0x
Consumed gas: `10`

### Two levels of call

This should execute fine, going into one two depths of call

Bytecode: `0x5f00045F00025200` (`RCALLSUB 4, RCALLSUB 2, RETURNSUB, RETURNSUB, STOP`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |   RCALLSUB  |    5 |        [] |        [] |
|    3  |   RCALLSUB  |    5 |        [] |        [] |
|    4  |  RETURNSUB  |    5 |        [] |        [] |
|    5  |  RETURNSUB  |    5 |        [] |        [] |
|    6  |       STOP  |    0 |        [] |        [] |

Consumed gas: `20`

### Failure 1: invalid jump

This should fail, since the given location is outside of the code-range.

Bytecode: `0X5fff`(`RCALLSUB -1`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |   RCALLSUB  |   10 |        [] |        [] |

```

Error: at pc=0, op=RCALLSUB: invalid jump destination

```

### Failure 2: shallow `return stack`

This should fail at first opcode, due to shallow `return_stack`

Bytecode: `0x5e` (`RETURNSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |  RETURNSUB  |    5 |        [] |        [] |

```

Error: at pc=0, op=RETURNSUB: invalid retsub

```

### call at end of code

In this example the RCALLSUB is on the last byte of code. When the call returns, it should hit the 'virtual stop' _after_ the bytecode, and not exit with error

Bytecode: `0x5c00045e5fffff` (`RJUMP 4, RETURNSUB, RCALLSUB -1`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      RJUMP  |    5 |        [] |        [] |
|    3  |  RETURNSUB  |    5 |        [] |        [] |
|    4  |   RCALLSUB  |    5 |        [] |        [] |
|    7  |       STOP  |    0 |        [] |        [] |

Consumed gas: `15`

## Reference Implementation

The following is a pseudo-Python implementation of an algorithm for predicating code validity.  An equivalent algorithm must be run at initialization time.

This algorithm performs a symbolic execution of the program that recursively traces the _code_, emulating its control flow and stack use and checking for violations of the rules above.

It runs in time equal to `O(vertices + edges)` in the program's control-flow graph, where edges represent control flow and the vertices represent _basic blocks_ — thus the algorithm takes time proportional to the size of the _code_. It maintains a stack of continuations for conditional jumps, the size of which is at most proportional to the size of the _code_.

### Validation Function

** Note: this function is known to be incomplete and incorrect. **

For simplicity's sake we assume that all jumpdest analysis and prior validation has been done, including EIP-3540, EIP-3670, and EIP-4200, so EOF headers and sections are well-formed, and there are no invalid instructions or jumps.  In practice, all passes of validation can be folded into a single loop with no recursion.

We also assume some helper functions.

* `is_valid(opcode)` returns true iff opcode is valid.
* `is_terminator(opcode)` returns true iff opcode is terminator.
* `is_valid_jumpdest(pc)` returns true iff `pc` is a valid jump destination.
* `immediate_data(pc)` returns the immediate data for the instruction at `pc`.
* `immediate_size(opcode)` returns the size of the immediate data for an opcode.
* `removed_items(opcode)` returns the number of items removed from the `data_stack` by the `opcode`.
* `added_items(opcode)` returns the number of items added to the `data_stack` by the `opcode`.

```
# returns true iff code is valid
def validate_code(code: bytes, pc: int, sp: int, bp: int) -> boolean:
    continuations = []
    do
        while pc < len(code):
            opcode = code[pc]
            if !is_valid(opcode):
                return false
            if is_terminator(opcode):
                return true

            # check stack height and return if we have been here before
            stack_height = sp - bp
            if stack_height > 1024
                return false
            if pos in stack_heights:
                if stack_height != stack_heights[pos]:
                    return false
                return true
            else:
                stack_heights[pos] = stack_height

            if opcode == RJUMP:

                # reset pc to destination of jump
                jumpdest = immediate_data(pc)
                pc += jumpdest
                if !is_valid_jumpdest(pc)
                    return false

            elif opcode == RJUMPI:

                jumpdest = pc + immediate_data(pc)
                if !is_valid_jumpdest(pc)
                    return false

                # continue true side of conditional later
                continuations.push((jumpdest, sp, bp))

                # continue false side of conditional now

            elif opcode == RCALLSUB:

                # will enter call at destination
                bp = sp

                # push return address and reset pc to destination
                jumpdest = pc + immediate_data(pc)
                if !is_valid_jumpdest(pc)
                    return false
                push(return_stack, pc + 3)
                pc = jumpdest
                continue

            elif opcode == RETURNSUB:

                # will return to call at destination
                bp = sp

                # pop return address and check for preceding call
                pc = pop(return_stack)
                if code[pc - 3] != RCALLSUB:
                   return false

            # apply instructions to stack
            sp -= removed_items(opcode)
            if sp < 0
                return false
            sp += added_items(opcode)

            # Skip opcode and immediate data
            pc += 1 + immediate_size(opcode)

        while (pc, sp, bp) = continuations.pop()

    return true
```

## Security Considerations

These changes introduce new flow control instructions.  They do not introduce any new security considerations. This EIP is intended to improve security by validating a higher level of safety for EVM code deployed on the blockchain.  The validation algorithm must be linear in time and space to not be a denial of service vulnerability.  The algorithm here makes one linear-time pass of the bytecode, and uses a stack of continuations that cannot exceed the number of `RJUMP` and `RJUMPI` instructions in the code.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
